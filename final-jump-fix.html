<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆ</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #87ceeb 0%, #98fb98 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      #game-container {
        background: #000;
        border: 3px solid #333;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      #game-canvas {
        display: block;
        background: #5c94fc;
      }

      #controls {
        margin: 20px 0;
        text-align: center;
        background: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      #debug-panel {
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        margin: 10px 0;
        max-width: 800px;
      }

      button {
        background: #2196f3;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }

      button:hover {
        background: #1976d2;
      }

      .status {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 3px;
        margin: 2px;
        font-weight: bold;
      }

      .status.good {
        background: #4caf50;
        color: white;
      }
      .status.bad {
        background: #f44336;
        color: white;
      }
      .status.warning {
        background: #ff9800;
        color: white;
      }

      .key-indicator {
        display: inline-block;
        margin: 5px;
        padding: 8px 12px;
        border: 2px solid #ddd;
        border-radius: 5px;
        background: #f9f9f9;
        font-family: monospace;
        font-weight: bold;
      }

      .key-indicator.pressed {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }

      .key-indicator.jump-key {
        border-color: #2196f3;
      }

      .key-indicator.jump-key.pressed {
        background: #ff5722;
        border-color: #ff5722;
      }

      .jump-success {
        background: #4caf50;
        color: white;
        padding: 10px;
        border-radius: 5px;
        margin: 10px 0;
        text-align: center;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>ğŸ¦˜ æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆ</h1>

    <div id="controls">
      <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
      <p><strong>ç§»å‹•:</strong> â†â†’ ã¾ãŸã¯ A/D</p>
      <p><strong>ã‚¸ãƒ£ãƒ³ãƒ—:</strong> ã‚¹ãƒšãƒ¼ã‚¹ ã¾ãŸã¯ â†‘ ã¾ãŸã¯ W ã¾ãŸã¯ Enter</p>

      <h4>ğŸ” ã‚­ãƒ¼çŠ¶æ…‹ç›£è¦–</h4>
      <div id="key-indicators">
        <div class="key-indicator jump-key" id="key-Space">Space</div>
        <div class="key-indicator jump-key" id="key-ArrowUp">â†‘</div>
        <div class="key-indicator jump-key" id="key-KeyW">W</div>
        <div class="key-indicator jump-key" id="key-Enter">Enter</div>
        <div class="key-indicator" id="key-ArrowLeft">â†</div>
        <div class="key-indicator" id="key-ArrowRight">â†’</div>
        <div class="key-indicator" id="key-KeyA">A</div>
        <div class="key-indicator" id="key-KeyD">D</div>
      </div>

      <div
        id="jump-success-indicator"
        class="jump-success"
        style="display: none"
      >
        ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—æˆåŠŸï¼
      </div>
    </div>

    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600" tabindex="0"></canvas>
    </div>

    <div id="debug-panel">
      <div>
        FPS: <span id="fps">0</span> | ä½ç½®: <span id="position">0, 0</span> |
        é€Ÿåº¦: <span id="velocity">0, 0</span> | åœ°é¢:
        <span id="ground" class="status">-</span> | çŠ¶æ…‹:
        <span id="state">idle</span>
      </div>

      <div style="margin-top: 5px">
        å…¥åŠ›çŠ¶æ…‹: <span id="input-status">-</span> | æœ€å¾Œã®ã‚­ãƒ¼:
        <span id="last-key">-</span> | ã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡º:
        <span id="jump-detected" class="status">-</span> | ã‚­ãƒ¼çŠ¶æ…‹å¤‰åŒ–:
        <span id="key-state-change" class="status">-</span>
      </div>

      <div style="margin-top: 10px">
        <button onclick="testJump()">ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="forceJump()">ğŸ’ª å¼·åˆ¶ã‚¸ãƒ£ãƒ³ãƒ—</button>
        <button onclick="resetPlayer()">ğŸ”„ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚»ãƒƒãƒˆ</button>
        <button onclick="debugInput()">ğŸ” å…¥åŠ›ãƒ‡ãƒãƒƒã‚°</button>
        <button onclick="testKeyStateLogic()">ğŸ”§ ã‚­ãƒ¼çŠ¶æ…‹ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆ</button>
      </div>

      <div
        id="debug-log"
        style="
          margin-top: 10px;
          max-height: 150px;
          overflow-y: auto;
          background: #222;
          padding: 5px;
          border-radius: 3px;
        "
      ></div>
    </div>

    <script>
      // å®Œå…¨ã«ä¿®æ­£ã•ã‚ŒãŸInputManager - ã‚­ãƒ¼çŠ¶æ…‹å¤‰åŒ–ã®æ¤œå‡ºã‚’ä¿®æ­£
      class FinalInputManager {
        constructor(canvas) {
          this.canvas = canvas;
          this.keys = {};
          this.prevKeys = {};
          this.lastKeyPressed = null;
          this.frameCount = 0;

          // ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
          this.jumpKeys = ["Space", "ArrowUp", "KeyW", "Enter"];
          this.leftKeys = ["ArrowLeft", "KeyA"];
          this.rightKeys = ["ArrowRight", "KeyD"];

          // ãƒ‡ãƒãƒƒã‚°ç”¨
          this.keyStateChanges = [];
          this.jumpDetectionAttempts = [];

          this.setupEventListeners();
          this.canvas.focus();

          debugLog("âœ… FinalInputManageråˆæœŸåŒ–å®Œäº†");
          debugLog(`ğŸ”§ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼è¨­å®š: ${this.jumpKeys.join(", ")}`);
        }

        setupEventListeners() {
          const keydownHandler = (e) => {
            const keyCode = e.code;
            const wasPressed = this.keys[keyCode];

            this.keys[keyCode] = true;
            this.lastKeyPressed = keyCode;

            // ã‚­ãƒ¼çŠ¶æ…‹å¤‰åŒ–ã‚’è¨˜éŒ²
            if (!wasPressed) {
              this.keyStateChanges.push({
                key: keyCode,
                action: "pressed",
                time: performance.now(),
                frame: this.frameCount,
              });
            }

            // ã‚­ãƒ¼è¡¨ç¤ºæ›´æ–°
            this.updateKeyIndicator(keyCode, true);

            // ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ã®ç‰¹åˆ¥å‡¦ç†
            if (this.jumpKeys.includes(keyCode)) {
              debugLog(
                `ğŸ”½ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æŠ¼ä¸‹: ${keyCode} (åˆå›: ${!wasPressed}, ãƒ•ãƒ¬ãƒ¼ãƒ : ${
                  this.frameCount
                })`
              );
              e.preventDefault();
              e.stopPropagation();
            }

            // ç§»å‹•ã‚­ãƒ¼ã®å‡¦ç†
            if (
              this.leftKeys.includes(keyCode) ||
              this.rightKeys.includes(keyCode)
            ) {
              e.preventDefault();
              debugLog(`ğŸ”½ ç§»å‹•ã‚­ãƒ¼æŠ¼ä¸‹: ${keyCode}`);
            }
          };

          const keyupHandler = (e) => {
            const keyCode = e.code;
            this.keys[keyCode] = false;

            // ã‚­ãƒ¼çŠ¶æ…‹å¤‰åŒ–ã‚’è¨˜éŒ²
            this.keyStateChanges.push({
              key: keyCode,
              action: "released",
              time: performance.now(),
              frame: this.frameCount,
            });

            // ã‚­ãƒ¼è¡¨ç¤ºæ›´æ–°
            this.updateKeyIndicator(keyCode, false);

            if (
              this.jumpKeys.includes(keyCode) ||
              this.leftKeys.includes(keyCode) ||
              this.rightKeys.includes(keyCode)
            ) {
              e.preventDefault();
              debugLog(
                `ğŸ”¼ ã‚­ãƒ¼é›¢ä¸Š: ${keyCode} (ãƒ•ãƒ¬ãƒ¼ãƒ : ${this.frameCount})`
              );
            }
          };

          // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
          document.addEventListener("keydown", keydownHandler, {
            passive: false,
            capture: true,
          });
          document.addEventListener("keyup", keyupHandler, {
            passive: false,
            capture: true,
          });

          // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç®¡ç†
          this.canvas.addEventListener("click", () => {
            this.canvas.focus();
            debugLog("ğŸ¯ ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ã‚«ã‚¹");
          });
        }

        updateKeyIndicator(keyCode, pressed) {
          const indicator = document.getElementById("key-" + keyCode);
          if (indicator) {
            if (pressed) {
              indicator.classList.add("pressed");
            } else {
              indicator.classList.remove("pressed");
            }
          }
        }

        update() {
          this.frameCount++;

          // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ä¿å­˜ï¼ˆé‡è¦ï¼ï¼‰
          this.prevKeys = { ...this.keys };

          // ãƒ­ã‚°ã‚µã‚¤ã‚ºåˆ¶é™
          if (this.keyStateChanges.length > 100) {
            this.keyStateChanges = this.keyStateChanges.slice(-50);
          }
          if (this.jumpDetectionAttempts.length > 50) {
            this.jumpDetectionAttempts = this.jumpDetectionAttempts.slice(-25);
          }
        }

        isKeyPressed(keyCode) {
          const current = this.keys[keyCode] || false;
          const previous = this.prevKeys[keyCode] || false;
          const pressed = current && !previous;

          // è©³ç´°ãªãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
          if (this.jumpKeys.includes(keyCode)) {
            const debugInfo = {
              key: keyCode,
              current: current,
              previous: previous,
              pressed: pressed,
              frame: this.frameCount,
            };

            this.jumpDetectionAttempts.push(debugInfo);

            if (pressed) {
              debugLog(
                `ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æ¤œå‡º: ${keyCode} (current: ${current}, previous: ${previous})`
              );
              this.showJumpSuccess();
            } else if (current) {
              debugLog(`ğŸ”„ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ç¶™ç¶š: ${keyCode} (already pressed)`);
            }
          }

          return pressed;
        }

        isKeyHeld(keyCode) {
          return this.keys[keyCode] || false;
        }

        showJumpSuccess() {
          const indicator = document.getElementById("jump-success-indicator");
          if (indicator) {
            indicator.style.display = "block";
            setTimeout(() => {
              indicator.style.display = "none";
            }, 1000);
          }
        }

        getInput() {
          // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡º
          const jumpPressed = this.jumpKeys.some((key) => {
            const pressed = this.isKeyPressed(key);
            if (pressed) {
              debugLog(`ğŸ¯ ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ç¢ºèª: ${key}`);
            }
            return pressed;
          });

          const jumpHeld = this.jumpKeys.some((key) => this.isKeyHeld(key));
          const moveLeft = this.leftKeys.some((key) => this.isKeyHeld(key));
          const moveRight = this.rightKeys.some((key) => this.isKeyHeld(key));

          const input = {
            jump: jumpPressed,
            jumpHeld: jumpHeld,
            moveLeft: moveLeft,
            moveRight: moveRight,
          };

          // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
          this.updateDebugUI(input);

          return input;
        }

        updateDebugUI(input) {
          const inputStatus = document.getElementById("input-status");
          const lastKey = document.getElementById("last-key");
          const jumpDetected = document.getElementById("jump-detected");
          const keyStateChange = document.getElementById("key-state-change");

          if (inputStatus) {
            const activeInputs = [];
            if (input.jump) activeInputs.push("JUMP");
            if (input.moveLeft) activeInputs.push("LEFT");
            if (input.moveRight) activeInputs.push("RIGHT");
            inputStatus.textContent = activeInputs.join(", ") || "ãªã—";
          }

          if (lastKey) {
            lastKey.textContent = this.lastKeyPressed || "ãªã—";
          }

          if (jumpDetected) {
            if (input.jump) {
              jumpDetected.textContent = "ã¯ã„";
              jumpDetected.className = "status good";
            } else {
              jumpDetected.textContent = "ã„ã„ãˆ";
              jumpDetected.className = "status bad";
            }
          }

          if (keyStateChange) {
            const recentChanges = this.keyStateChanges.filter(
              (change) => performance.now() - change.time < 1000
            );
            if (recentChanges.length > 0) {
              keyStateChange.textContent = `${recentChanges.length}ä»¶`;
              keyStateChange.className = "status good";
            } else {
              keyStateChange.textContent = "ãªã—";
              keyStateChange.className = "status bad";
            }
          }
        }

        getDebugInfo() {
          return {
            keys: { ...this.keys },
            prevKeys: { ...this.prevKeys },
            lastKeyPressed: this.lastKeyPressed,
            frameCount: this.frameCount,
            recentKeyStateChanges: this.keyStateChanges.slice(-10),
            recentJumpDetectionAttempts: this.jumpDetectionAttempts.slice(-5),
            focusState: {
              activeElement: document.activeElement === this.canvas,
              hasFocus: document.hasFocus(),
              canvasTabIndex: this.canvas.tabIndex,
            },
          };
        }
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆå¤‰æ›´ãªã—ï¼‰
      class FinalPlayer {
        constructor(x, y) {
          this.position = { x: x || 100, y: y || 400 };
          this.velocity = { x: 0, y: 0 };
          this.size = { width: 32, height: 32 };

          // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
          this.moveSpeed = 200;
          this.jumpPower = 400;
          this.gravity = 980;
          this.friction = 0.8;

          // çŠ¶æ…‹
          this.isOnGround = false;
          this.state = "idle";
          this.facing = "right";

          debugLog("âœ… FinalPlayeråˆæœŸåŒ–å®Œäº†");
        }

        update(deltaTime, input) {
          const dt = deltaTime / 1000;

          // ç§»å‹•å…¥åŠ›å‡¦ç†
          if (input.moveLeft) {
            this.velocity.x = -this.moveSpeed;
            this.facing = "left";
            if (this.isOnGround) this.state = "running";
          } else if (input.moveRight) {
            this.velocity.x = this.moveSpeed;
            this.facing = "right";
            if (this.isOnGround) this.state = "running";
          } else {
            this.velocity.x *= this.friction;
            if (this.isOnGround && Math.abs(this.velocity.x) < 10) {
              this.velocity.x = 0;
              this.state = "idle";
            }
          }

          // ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›å‡¦ç† - ã‚ˆã‚Šè©³ç´°ãªãƒ­ã‚°
          if (input.jump) {
            debugLog(
              `ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›å—ä¿¡ - åœ°é¢: ${this.isOnGround}, çŠ¶æ…‹: ${
                this.state
              }, Yä½ç½®: ${this.position.y.toFixed(1)}`
            );
            if (this.isOnGround) {
              const jumpResult = this.jump();
              debugLog(`ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—å®Ÿè¡Œçµæœ: ${jumpResult ? "æˆåŠŸ" : "å¤±æ•—"}`);
            } else {
              debugLog(
                `âŒ ã‚¸ãƒ£ãƒ³ãƒ—å¤±æ•— - åœ°é¢ã«ã„ã¾ã›ã‚“ (y: ${this.position.y.toFixed(
                  1
                )}, ground: ${this.isOnGround})`
              );
            }
          }

          // é‡åŠ›é©ç”¨
          if (!this.isOnGround) {
            this.velocity.y += this.gravity * dt;
            this.state = "jumping";
          }

          // ä½ç½®æ›´æ–°
          this.position.x += this.velocity.x * dt;
          this.position.y += this.velocity.y * dt;

          // åœ°é¢è¡çªãƒã‚§ãƒƒã‚¯
          const groundY = 550;
          if (this.position.y + this.size.height >= groundY) {
            this.position.y = groundY - this.size.height;
            this.velocity.y = 0;
            this.isOnGround = true;
          } else {
            this.isOnGround = false;
          }

          // ç”»é¢ç«¯åˆ¶é™
          if (this.position.x < 0) {
            this.position.x = 0;
            this.velocity.x = 0;
          } else if (this.position.x + this.size.width > 800) {
            this.position.x = 800 - this.size.width;
            this.velocity.x = 0;
          }
        }

        jump() {
          if (this.isOnGround) {
            this.velocity.y = -this.jumpPower;
            this.isOnGround = false;
            this.state = "jumping";
            debugLog("ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—å®Ÿè¡ŒæˆåŠŸï¼é€Ÿåº¦è¨­å®šå®Œäº†");
            return true;
          }
          debugLog("âŒ ã‚¸ãƒ£ãƒ³ãƒ—å¤±æ•— - åœ°é¢ã«ã„ã¾ã›ã‚“");
          return false;
        }

        render(ctx) {
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“
          ctx.fillStyle = this.isOnGround ? "#FF0000" : "#FF6666";
          ctx.fillRect(
            this.position.x,
            this.position.y,
            this.size.width,
            this.size.height
          );

          // å‘ãè¡¨ç¤º
          ctx.fillStyle = "#FFFFFF";
          const centerX = this.position.x + this.size.width / 2;
          const centerY = this.position.y + this.size.height / 2;

          ctx.beginPath();
          if (this.facing === "right") {
            ctx.moveTo(centerX + 8, centerY);
            ctx.lineTo(centerX + 2, centerY - 4);
            ctx.lineTo(centerX + 2, centerY + 4);
          } else {
            ctx.moveTo(centerX - 8, centerY);
            ctx.lineTo(centerX - 2, centerY - 4);
            ctx.lineTo(centerX - 2, centerY + 4);
          }
          ctx.closePath();
          ctx.fill();

          // ã‚¸ãƒ£ãƒ³ãƒ—è»Œè·¡
          if (!this.isOnGround) {
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        reset() {
          this.position = { x: 100, y: 400 };
          this.velocity = { x: 0, y: 0 };
          this.isOnGround = true;
          this.state = "idle";
          debugLog("ğŸ”„ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚»ãƒƒãƒˆ");
        }
      }

      // ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
      class FinalGame {
        constructor() {
          this.canvas = document.getElementById("game-canvas");
          this.ctx = this.canvas.getContext("2d");

          // UIè¦ç´ 
          this.debugElements = {
            fps: document.getElementById("fps"),
            position: document.getElementById("position"),
            velocity: document.getElementById("velocity"),
            ground: document.getElementById("ground"),
            state: document.getElementById("state"),
          };

          // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
          this.inputManager = new FinalInputManager(this.canvas);
          this.player = new FinalPlayer(100, 400);

          // ã‚¿ã‚¤ãƒŸãƒ³ã‚°
          this.lastTime = 0;
          this.fps = 0;
          this.frameCount = 0;
          this.fpsTime = 0;

          debugLog("âœ… FinalGameåˆæœŸåŒ–å®Œäº†");
          this.start();
        }

        start() {
          this.gameLoop();
        }

        gameLoop() {
          const currentTime = performance.now();
          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;

          // FPSè¨ˆç®—
          this.frameCount++;
          if (currentTime - this.fpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.fpsTime = currentTime;
          }

          this.update(deltaTime);
          this.render();
          this.updateUI();

          requestAnimationFrame(() => this.gameLoop());
        }

        update(deltaTime) {
          // é‡è¦ï¼šInputManagerã®updateã‚’æœ€åˆã«å‘¼ã¶
          this.inputManager.update();
          const input = this.inputManager.getInput();

          this.player.update(deltaTime, input);
        }

        render() {
          // èƒŒæ™¯
          this.ctx.fillStyle = "#5C94FC";
          this.ctx.fillRect(0, 0, 800, 600);

          // åœ°é¢
          this.ctx.fillStyle = "#8B4513";
          this.ctx.fillRect(0, 550, 800, 50);

          // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
          this.ctx.fillStyle = "#228B22";
          this.ctx.fillRect(200, 450, 150, 20);
          this.ctx.fillRect(400, 350, 150, 20);
          this.ctx.fillRect(600, 250, 150, 20);

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
          this.player.render(this.ctx);

          // æ“ä½œèª¬æ˜
          this.ctx.fillStyle = "white";
          this.ctx.font = "16px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText("ä»Šåº¦ã“ãã‚¸ãƒ£ãƒ³ãƒ—ã§ãã‚‹ã¯ãšï¼", 400, 30);
        }

        updateUI() {
          this.debugElements.fps.textContent = this.fps;
          this.debugElements.position.textContent = `${Math.round(
            this.player.position.x
          )}, ${Math.round(this.player.position.y)}`;
          this.debugElements.velocity.textContent = `${Math.round(
            this.player.velocity.x
          )}, ${Math.round(this.player.velocity.y)}`;

          const groundElement = this.debugElements.ground;
          if (this.player.isOnGround) {
            groundElement.textContent = "ã¯ã„";
            groundElement.className = "status good";
          } else {
            groundElement.textContent = "ã„ã„ãˆ";
            groundElement.className = "status bad";
          }

          this.debugElements.state.textContent = this.player.state;
        }
      }

      // ãƒ‡ãƒãƒƒã‚°é–¢æ•°
      let game = null;
      let debugLogElement = null;

      function debugLog(message) {
        console.log(message);
        if (debugLogElement) {
          const timestamp = new Date().toLocaleTimeString();
          debugLogElement.innerHTML += `[${timestamp}] ${message}\n`;
          debugLogElement.scrollTop = debugLogElement.scrollHeight;
        }
      }

      function testJump() {
        if (game && game.player) {
          const result = game.player.jump();
          debugLog(`ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¸ãƒ£ãƒ³ãƒ—: ${result ? "æˆåŠŸ" : "å¤±æ•—"}`);
          return result;
        }
        return false;
      }

      function forceJump() {
        if (game && game.player) {
          game.player.position.y = 518;
          game.player.velocity.y = 0;
          game.player.isOnGround = true;
          const result = game.player.jump();
          debugLog(`ğŸ’ª å¼·åˆ¶ã‚¸ãƒ£ãƒ³ãƒ—: ${result ? "æˆåŠŸ" : "å¤±æ•—"}`);
          return result;
        }
        return false;
      }

      function resetPlayer() {
        if (game && game.player) {
          game.player.reset();
          return true;
        }
        return false;
      }

      function debugInput() {
        if (game && game.inputManager) {
          const debugInfo = game.inputManager.getDebugInfo();
          debugLog("ğŸ” å…¥åŠ›ãƒ‡ãƒãƒƒã‚°æƒ…å ±:");
          debugLog(`  ç¾åœ¨ã®ã‚­ãƒ¼: ${JSON.stringify(debugInfo.keys)}`);
          debugLog(`  å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚­ãƒ¼: ${JSON.stringify(debugInfo.prevKeys)}`);
          debugLog(`  æœ€å¾Œã®ã‚­ãƒ¼: ${debugInfo.lastKeyPressed || "ãªã—"}`);
          debugLog(`  ãƒ•ãƒ¬ãƒ¼ãƒ æ•°: ${debugInfo.frameCount}`);
          debugLog(
            `  æœ€è¿‘ã®ã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡ºè©¦è¡Œ: ${debugInfo.recentJumpDetectionAttempts.length}ä»¶`
          );
          return debugInfo;
        }
        return null;
      }

      function testKeyStateLogic() {
        debugLog("ğŸ”§ ã‚­ãƒ¼çŠ¶æ…‹ãƒ­ã‚¸ãƒƒã‚¯ãƒ†ã‚¹ãƒˆé–‹å§‹");

        if (game && game.inputManager) {
          const manager = game.inputManager;

          // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒ­ã‚°
          debugLog(`ç¾åœ¨ã®ã‚­ãƒ¼çŠ¶æ…‹: ${JSON.stringify(manager.keys)}`);
          debugLog(`å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚­ãƒ¼çŠ¶æ…‹: ${JSON.stringify(manager.prevKeys)}`);

          // å„ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ã®çŠ¶æ…‹ã‚’ãƒ†ã‚¹ãƒˆ
          manager.jumpKeys.forEach((key) => {
            const current = manager.keys[key] || false;
            const previous = manager.prevKeys[key] || false;
            const pressed = current && !previous;

            debugLog(
              `${key}: current=${current}, previous=${previous}, pressed=${pressed}`
            );
          });

          return {
            keys: manager.keys,
            prevKeys: manager.prevKeys,
            frameCount: manager.frameCount,
          };
        }

        return null;
      }

      // åˆæœŸåŒ–
      window.addEventListener("load", () => {
        debugLogElement = document.getElementById("debug-log");
        debugLog("ğŸš€ æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆåˆæœŸåŒ–ä¸­...");

        try {
          game = new FinalGame();
          debugLog("ğŸ® ã‚²ãƒ¼ãƒ æº–å‚™å®Œäº†ï¼");
          debugLog("ğŸ”§ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚¸ãƒ£ãƒ³ãƒ—ã‚’è©¦ã—ã¦ãã ã•ã„ï¼");

          // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
          window.game = game;
          window.testJump = testJump;
          window.forceJump = forceJump;
          window.resetPlayer = resetPlayer;
          window.debugInput = debugInput;
          window.testKeyStateLogic = testKeyStateLogic;
        } catch (error) {
          debugLog("âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + error.message);
          console.error("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
        }
      });
    </script>
  </body>
</html>
