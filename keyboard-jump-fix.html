<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆ</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #87ceeb 0%, #98fb98 100%);
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }

      #game-container {
        background: #000;
        border: 3px solid #333;
        border-radius: 8px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        position: relative;
      }

      #game-canvas {
        display: block;
        background: #5c94fc;
      }

      #controls {
        margin: 20px 0;
        text-align: center;
        background: white;
        padding: 15px;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      #debug-panel {
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        margin: 10px 0;
        max-width: 800px;
      }

      button {
        background: #2196f3;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        margin: 5px;
        font-size: 14px;
      }

      button:hover {
        background: #1976d2;
      }

      .status {
        display: inline-block;
        padding: 5px 10px;
        border-radius: 3px;
        margin: 2px;
        font-weight: bold;
      }

      .status.good {
        background: #4caf50;
        color: white;
      }
      .status.bad {
        background: #f44336;
        color: white;
      }
      .status.warning {
        background: #ff9800;
        color: white;
      }

      .key-indicator {
        display: inline-block;
        margin: 5px;
        padding: 8px 12px;
        border: 2px solid #ddd;
        border-radius: 5px;
        background: #f9f9f9;
        font-family: monospace;
        font-weight: bold;
      }

      .key-indicator.pressed {
        background: #4caf50;
        color: white;
        border-color: #4caf50;
      }

      .key-indicator.jump-key {
        border-color: #2196f3;
      }

      .key-indicator.jump-key.pressed {
        background: #ff5722;
        border-color: #ff5722;
      }
    </style>
  </head>
  <body>
    <h1>ğŸ¦˜ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆ</h1>

    <div id="controls">
      <h3>ğŸ® æ“ä½œæ–¹æ³•</h3>
      <p><strong>ç§»å‹•:</strong> â†â†’ ã¾ãŸã¯ A/D</p>
      <p><strong>ã‚¸ãƒ£ãƒ³ãƒ—:</strong> ã‚¹ãƒšãƒ¼ã‚¹ ã¾ãŸã¯ â†‘ ã¾ãŸã¯ W ã¾ãŸã¯ Enter</p>

      <h4>ğŸ” ã‚­ãƒ¼çŠ¶æ…‹ç›£è¦–</h4>
      <div id="key-indicators">
        <div class="key-indicator jump-key" id="key-Space">Space</div>
        <div class="key-indicator jump-key" id="key-ArrowUp">â†‘</div>
        <div class="key-indicator jump-key" id="key-KeyW">W</div>
        <div class="key-indicator jump-key" id="key-Enter">Enter</div>
        <div class="key-indicator" id="key-ArrowLeft">â†</div>
        <div class="key-indicator" id="key-ArrowRight">â†’</div>
        <div class="key-indicator" id="key-KeyA">A</div>
        <div class="key-indicator" id="key-KeyD">D</div>
      </div>
    </div>

    <div id="game-container">
      <canvas id="game-canvas" width="800" height="600" tabindex="0"></canvas>
    </div>

    <div id="debug-panel">
      <div>
        FPS: <span id="fps">0</span> | ä½ç½®: <span id="position">0, 0</span> |
        é€Ÿåº¦: <span id="velocity">0, 0</span> | åœ°é¢:
        <span id="ground" class="status">-</span> | çŠ¶æ…‹:
        <span id="state">idle</span>
      </div>

      <div style="margin-top: 5px">
        å…¥åŠ›çŠ¶æ…‹: <span id="input-status">-</span> | æœ€å¾Œã®ã‚­ãƒ¼:
        <span id="last-key">-</span> | ã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡º:
        <span id="jump-detected" class="status">-</span>
      </div>

      <div style="margin-top: 10px">
        <button onclick="testJump()">ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—ãƒ†ã‚¹ãƒˆ</button>
        <button onclick="forceJump()">ğŸ’ª å¼·åˆ¶ã‚¸ãƒ£ãƒ³ãƒ—</button>
        <button onclick="resetPlayer()">ğŸ”„ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚»ãƒƒãƒˆ</button>
        <button onclick="debugInput()">ğŸ” å…¥åŠ›ãƒ‡ãƒãƒƒã‚°</button>
        <button onclick="testKeyDetection()">âŒ¨ï¸ ã‚­ãƒ¼æ¤œå‡ºãƒ†ã‚¹ãƒˆ</button>
      </div>

      <div
        id="debug-log"
        style="
          margin-top: 10px;
          max-height: 150px;
          overflow-y: auto;
          background: #222;
          padding: 5px;
          border-radius: 3px;
        "
      ></div>
    </div>

    <script>
      // æ”¹è‰¯ã•ã‚ŒãŸInputManager - ã‚­ãƒ¼æ¤œå‡ºã®å•é¡Œã‚’ä¿®æ­£
      class FixedInputManager {
        constructor(canvas) {
          this.canvas = canvas;
          this.keys = {};
          this.prevKeys = {};
          this.lastKeyPressed = null;
          this.keyPressCount = {};

          // ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
          this.jumpKeys = ["Space", "ArrowUp", "KeyW", "Enter"];
          this.leftKeys = ["ArrowLeft", "KeyA"];
          this.rightKeys = ["ArrowRight", "KeyD"];

          // ãƒ‡ãƒãƒƒã‚°ç”¨
          this.keyEventLog = [];
          this.jumpDetectionLog = [];

          this.setupEventListeners();
          this.canvas.focus();

          debugLog("âœ… FixedInputManageråˆæœŸåŒ–å®Œäº†");
          debugLog(`ğŸ”§ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼è¨­å®š: ${this.jumpKeys.join(", ")}`);
        }

        setupEventListeners() {
          // ã‚ˆã‚Šç¢ºå®Ÿãªã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆæ¤œå‡º
          const keydownHandler = (e) => {
            const keyCode = e.code;
            const wasPressed = this.keys[keyCode];

            this.keys[keyCode] = true;
            this.lastKeyPressed = keyCode;
            this.keyPressCount[keyCode] =
              (this.keyPressCount[keyCode] || 0) + 1;

            // ã‚­ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆãƒ­ã‚°
            this.keyEventLog.push({
              type: "keydown",
              key: keyCode,
              time: performance.now(),
              wasPressed: wasPressed,
            });

            // ã‚­ãƒ¼è¡¨ç¤ºæ›´æ–°
            this.updateKeyIndicator(keyCode, true);

            // ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ã®ç‰¹åˆ¥å‡¦ç†
            if (this.jumpKeys.includes(keyCode)) {
              debugLog(
                `ğŸ”½ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æŠ¼ä¸‹: ${keyCode} (åˆå›: ${!wasPressed})`
              );

              // preventDefault ã‚’ç¢ºå®Ÿã«å®Ÿè¡Œ
              e.preventDefault();
              e.stopPropagation();

              // ã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡ºãƒ­ã‚°
              this.jumpDetectionLog.push({
                key: keyCode,
                time: performance.now(),
                wasPressed: wasPressed,
                prevented: e.defaultPrevented,
              });
            }

            // ç§»å‹•ã‚­ãƒ¼ã®å‡¦ç†
            if (
              this.leftKeys.includes(keyCode) ||
              this.rightKeys.includes(keyCode)
            ) {
              e.preventDefault();
              debugLog(`ğŸ”½ ç§»å‹•ã‚­ãƒ¼æŠ¼ä¸‹: ${keyCode}`);
            }
          };

          const keyupHandler = (e) => {
            const keyCode = e.code;
            this.keys[keyCode] = false;

            // ã‚­ãƒ¼è¡¨ç¤ºæ›´æ–°
            this.updateKeyIndicator(keyCode, false);

            if (
              this.jumpKeys.includes(keyCode) ||
              this.leftKeys.includes(keyCode) ||
              this.rightKeys.includes(keyCode)
            ) {
              e.preventDefault();
              debugLog(`ğŸ”¼ ã‚­ãƒ¼é›¢ä¸Š: ${keyCode}`);
            }
          };

          // è¤‡æ•°ã®æ–¹æ³•ã§ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
          document.addEventListener("keydown", keydownHandler, {
            passive: false,
            capture: true,
          });
          document.addEventListener("keyup", keyupHandler, {
            passive: false,
            capture: true,
          });

          // Canvasã«ã‚‚ç›´æ¥è¨­å®š
          this.canvas.addEventListener("keydown", keydownHandler, {
            passive: false,
          });
          this.canvas.addEventListener("keyup", keyupHandler, {
            passive: false,
          });

          // Windowã«ã‚‚è¨­å®šï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
          window.addEventListener("keydown", keydownHandler, {
            passive: false,
          });
          window.addEventListener("keyup", keyupHandler, { passive: false });

          // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ç®¡ç†
          this.canvas.addEventListener("click", () => {
            this.canvas.focus();
            debugLog("ğŸ¯ ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ã‚«ã‚¹");
          });

          // ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹ç›£è¦–
          this.canvas.addEventListener("focus", () => {
            debugLog("âœ… ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å–å¾—");
          });

          this.canvas.addEventListener("blur", () => {
            debugLog("âŒ ã‚­ãƒ£ãƒ³ãƒã‚¹ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å¤±å¤±");
          });
        }

        updateKeyIndicator(keyCode, pressed) {
          const indicator = document.getElementById("key-" + keyCode);
          if (indicator) {
            if (pressed) {
              indicator.classList.add("pressed");
            } else {
              indicator.classList.remove("pressed");
            }
          }
        }

        update() {
          // å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ä¿å­˜
          this.prevKeys = { ...this.keys };

          // ãƒ­ã‚°ã‚µã‚¤ã‚ºåˆ¶é™
          if (this.keyEventLog.length > 100) {
            this.keyEventLog = this.keyEventLog.slice(-50);
          }
          if (this.jumpDetectionLog.length > 50) {
            this.jumpDetectionLog = this.jumpDetectionLog.slice(-25);
          }
        }

        isKeyPressed(keyCode) {
          const current = this.keys[keyCode] || false;
          const previous = this.prevKeys[keyCode] || false;
          const pressed = current && !previous;

          if (pressed && this.jumpKeys.includes(keyCode)) {
            debugLog(`ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æ¤œå‡º: ${keyCode}`);
          }

          return pressed;
        }

        isKeyHeld(keyCode) {
          return this.keys[keyCode] || false;
        }

        getInput() {
          // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡º
          const jumpPressed = this.jumpKeys.some((key) => {
            const pressed = this.isKeyPressed(key);
            if (pressed) {
              debugLog(`ğŸ¯ ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ç¢ºèª: ${key}`);
            }
            return pressed;
          });

          const jumpHeld = this.jumpKeys.some((key) => this.isKeyHeld(key));
          const moveLeft = this.leftKeys.some((key) => this.isKeyHeld(key));
          const moveRight = this.rightKeys.some((key) => this.isKeyHeld(key));

          const input = {
            jump: jumpPressed,
            jumpHeld: jumpHeld,
            moveLeft: moveLeft,
            moveRight: moveRight,
          };

          // ãƒ‡ãƒãƒƒã‚°æƒ…å ±æ›´æ–°
          this.updateDebugUI(input);

          return input;
        }

        updateDebugUI(input) {
          const inputStatus = document.getElementById("input-status");
          const lastKey = document.getElementById("last-key");
          const jumpDetected = document.getElementById("jump-detected");

          if (inputStatus) {
            const activeInputs = [];
            if (input.jump) activeInputs.push("JUMP");
            if (input.moveLeft) activeInputs.push("LEFT");
            if (input.moveRight) activeInputs.push("RIGHT");
            inputStatus.textContent = activeInputs.join(", ") || "ãªã—";
          }

          if (lastKey) {
            lastKey.textContent = this.lastKeyPressed || "ãªã—";
          }

          if (jumpDetected) {
            if (input.jump) {
              jumpDetected.textContent = "ã¯ã„";
              jumpDetected.className = "status good";
            } else {
              jumpDetected.textContent = "ã„ã„ãˆ";
              jumpDetected.className = "status bad";
            }
          }
        }

        getDebugInfo() {
          return {
            keys: { ...this.keys },
            lastKeyPressed: this.lastKeyPressed,
            keyPressCount: { ...this.keyPressCount },
            recentKeyEvents: this.keyEventLog.slice(-10),
            recentJumpDetections: this.jumpDetectionLog.slice(-5),
            focusState: {
              activeElement: document.activeElement === this.canvas,
              hasFocus: document.hasFocus(),
              canvasTabIndex: this.canvas.tabIndex,
            },
          };
        }
      }

      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹ï¼ˆå¤‰æ›´ãªã—ï¼‰
      class FixedPlayer {
        constructor(x, y) {
          this.position = { x: x || 100, y: y || 400 };
          this.velocity = { x: 0, y: 0 };
          this.size = { width: 32, height: 32 };

          // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
          this.moveSpeed = 200;
          this.jumpPower = 400;
          this.gravity = 980;
          this.friction = 0.8;

          // çŠ¶æ…‹
          this.isOnGround = false;
          this.state = "idle";
          this.facing = "right";

          debugLog("âœ… FixedPlayeråˆæœŸåŒ–å®Œäº†");
        }

        update(deltaTime, input) {
          const dt = deltaTime / 1000;

          // ç§»å‹•å…¥åŠ›å‡¦ç†
          if (input.moveLeft) {
            this.velocity.x = -this.moveSpeed;
            this.facing = "left";
            if (this.isOnGround) this.state = "running";
          } else if (input.moveRight) {
            this.velocity.x = this.moveSpeed;
            this.facing = "right";
            if (this.isOnGround) this.state = "running";
          } else {
            this.velocity.x *= this.friction;
            if (this.isOnGround && Math.abs(this.velocity.x) < 10) {
              this.velocity.x = 0;
              this.state = "idle";
            }
          }

          // ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›å‡¦ç† - ã‚ˆã‚Šè©³ç´°ãªãƒ­ã‚°
          if (input.jump) {
            debugLog(
              `ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›å—ä¿¡ - åœ°é¢: ${this.isOnGround}, çŠ¶æ…‹: ${this.state}`
            );
            if (this.isOnGround) {
              this.jump();
            } else {
              debugLog(
                `âŒ ã‚¸ãƒ£ãƒ³ãƒ—å¤±æ•— - åœ°é¢ã«ã„ã¾ã›ã‚“ (y: ${this.position.y.toFixed(
                  1
                )})`
              );
            }
          }

          // é‡åŠ›é©ç”¨
          if (!this.isOnGround) {
            this.velocity.y += this.gravity * dt;
            this.state = "jumping";
          }

          // ä½ç½®æ›´æ–°
          this.position.x += this.velocity.x * dt;
          this.position.y += this.velocity.y * dt;

          // åœ°é¢è¡çªãƒã‚§ãƒƒã‚¯
          const groundY = 550;
          if (this.position.y + this.size.height >= groundY) {
            this.position.y = groundY - this.size.height;
            this.velocity.y = 0;
            this.isOnGround = true;
          } else {
            this.isOnGround = false;
          }

          // ç”»é¢ç«¯åˆ¶é™
          if (this.position.x < 0) {
            this.position.x = 0;
            this.velocity.x = 0;
          } else if (this.position.x + this.size.width > 800) {
            this.position.x = 800 - this.size.width;
            this.velocity.x = 0;
          }
        }

        jump() {
          if (this.isOnGround) {
            this.velocity.y = -this.jumpPower;
            this.isOnGround = false;
            this.state = "jumping";
            debugLog("ğŸ¦˜ ã‚¸ãƒ£ãƒ³ãƒ—å®Ÿè¡ŒæˆåŠŸï¼");
            return true;
          }
          debugLog("âŒ ã‚¸ãƒ£ãƒ³ãƒ—å¤±æ•— - åœ°é¢ã«ã„ã¾ã›ã‚“");
          return false;
        }

        render(ctx) {
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æœ¬ä½“
          ctx.fillStyle = this.isOnGround ? "#FF0000" : "#FF6666";
          ctx.fillRect(
            this.position.x,
            this.position.y,
            this.size.width,
            this.size.height
          );

          // å‘ãè¡¨ç¤º
          ctx.fillStyle = "#FFFFFF";
          const centerX = this.position.x + this.size.width / 2;
          const centerY = this.position.y + this.size.height / 2;

          ctx.beginPath();
          if (this.facing === "right") {
            ctx.moveTo(centerX + 8, centerY);
            ctx.lineTo(centerX + 2, centerY - 4);
            ctx.lineTo(centerX + 2, centerY + 4);
          } else {
            ctx.moveTo(centerX - 8, centerY);
            ctx.lineTo(centerX - 2, centerY - 4);
            ctx.lineTo(centerX - 2, centerY + 4);
          }
          ctx.closePath();
          ctx.fill();

          // ã‚¸ãƒ£ãƒ³ãƒ—è»Œè·¡
          if (!this.isOnGround) {
            ctx.strokeStyle = "yellow";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        reset() {
          this.position = { x: 100, y: 400 };
          this.velocity = { x: 0, y: 0 };
          this.isOnGround = true;
          this.state = "idle";
          debugLog("ğŸ”„ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚»ãƒƒãƒˆ");
        }
      }

      // ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
      class FixedGame {
        constructor() {
          this.canvas = document.getElementById("game-canvas");
          this.ctx = this.canvas.getContext("2d");

          // UIè¦ç´ 
          this.debugElements = {
            fps: document.getElementById("fps"),
            position: document.getElementById("position"),
            velocity: document.getElementById("velocity"),
            ground: document.getElementById("ground"),
            state: document.getElementById("state"),
          };

          // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
          this.inputManager = new FixedInputManager(this.canvas);
          this.player = new FixedPlayer(100, 400);

          // ã‚¿ã‚¤ãƒŸãƒ³ã‚°
          this.lastTime = 0;
          this.fps = 0;
          this.frameCount = 0;
          this.fpsTime = 0;

          debugLog("âœ… FixedGameåˆæœŸåŒ–å®Œäº†");
          this.start();
        }

        start() {
          this.gameLoop();
        }

        gameLoop() {
          const currentTime = performance.now();
          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;

          // FPSè¨ˆç®—
          this.frameCount++;
          if (currentTime - this.fpsTime >= 1000) {
            this.fps = this.frameCount;
            this.frameCount = 0;
            this.fpsTime = currentTime;
          }

          this.update(deltaTime);
          this.render();
          this.updateUI();

          requestAnimationFrame(() => this.gameLoop());
        }

        update(deltaTime) {
          this.inputManager.update();
          const input = this.inputManager.getInput();

          this.player.update(deltaTime, input);
        }

        render() {
          // èƒŒæ™¯
          this.ctx.fillStyle = "#5C94FC";
          this.ctx.fillRect(0, 0, 800, 600);

          // åœ°é¢
          this.ctx.fillStyle = "#8B4513";
          this.ctx.fillRect(0, 550, 800, 50);

          // ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ 
          this.ctx.fillStyle = "#228B22";
          this.ctx.fillRect(200, 450, 150, 20);
          this.ctx.fillRect(400, 350, 150, 20);
          this.ctx.fillRect(600, 250, 150, 20);

          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
          this.player.render(this.ctx);

          // æ“ä½œèª¬æ˜
          this.ctx.fillStyle = "white";
          this.ctx.font = "16px Arial";
          this.ctx.textAlign = "center";
          this.ctx.fillText("ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚¸ãƒ£ãƒ³ãƒ—ã—ã¦ã¿ã¦ï¼", 400, 30);
        }

        updateUI() {
          this.debugElements.fps.textContent = this.fps;
          this.debugElements.position.textContent = `${Math.round(
            this.player.position.x
          )}, ${Math.round(this.player.position.y)}`;
          this.debugElements.velocity.textContent = `${Math.round(
            this.player.velocity.x
          )}, ${Math.round(this.player.velocity.y)}`;

          const groundElement = this.debugElements.ground;
          if (this.player.isOnGround) {
            groundElement.textContent = "ã¯ã„";
            groundElement.className = "status good";
          } else {
            groundElement.textContent = "ã„ã„ãˆ";
            groundElement.className = "status bad";
          }

          this.debugElements.state.textContent = this.player.state;
        }
      }

      // ãƒ‡ãƒãƒƒã‚°é–¢æ•°
      let game = null;
      let debugLogElement = null;

      function debugLog(message) {
        console.log(message);
        if (debugLogElement) {
          const timestamp = new Date().toLocaleTimeString();
          debugLogElement.innerHTML += `[${timestamp}] ${message}\n`;
          debugLogElement.scrollTop = debugLogElement.scrollHeight;
        }
      }

      function testJump() {
        if (game && game.player) {
          const result = game.player.jump();
          debugLog(`ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¸ãƒ£ãƒ³ãƒ—: ${result ? "æˆåŠŸ" : "å¤±æ•—"}`);
          return result;
        }
        return false;
      }

      function forceJump() {
        if (game && game.player) {
          game.player.position.y = 518;
          game.player.velocity.y = 0;
          game.player.isOnGround = true;
          const result = game.player.jump();
          debugLog(`ğŸ’ª å¼·åˆ¶ã‚¸ãƒ£ãƒ³ãƒ—: ${result ? "æˆåŠŸ" : "å¤±æ•—"}`);
          return result;
        }
        return false;
      }

      function resetPlayer() {
        if (game && game.player) {
          game.player.reset();
          return true;
        }
        return false;
      }

      function debugInput() {
        if (game && game.inputManager) {
          const debugInfo = game.inputManager.getDebugInfo();
          debugLog("ğŸ” å…¥åŠ›ãƒ‡ãƒãƒƒã‚°æƒ…å ±:");
          debugLog(
            `  æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼: ${
              Object.keys(debugInfo.keys)
                .filter((k) => debugInfo.keys[k])
                .join(", ") || "ãªã—"
            }`
          );
          debugLog(`  æœ€å¾Œã®ã‚­ãƒ¼: ${debugInfo.lastKeyPressed || "ãªã—"}`);
          debugLog(`  ãƒ•ã‚©ãƒ¼ã‚«ã‚¹çŠ¶æ…‹: ${JSON.stringify(debugInfo.focusState)}`);
          debugLog(
            `  æœ€è¿‘ã®ã‚¸ãƒ£ãƒ³ãƒ—æ¤œå‡º: ${debugInfo.recentJumpDetections.length}ä»¶`
          );
          return debugInfo;
        }
        return null;
      }

      function testKeyDetection() {
        debugLog("âŒ¨ï¸ ã‚­ãƒ¼æ¤œå‡ºãƒ†ã‚¹ãƒˆé–‹å§‹ - 5ç§’é–“ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„");

        let testResults = {
          detectedKeys: [],
          jumpKeyPresses: 0,
          totalKeyPresses: 0,
        };

        const testHandler = (e) => {
          testResults.totalKeyPresses++;
          testResults.detectedKeys.push(e.code);

          if (["Space", "ArrowUp", "KeyW", "Enter"].includes(e.code)) {
            testResults.jumpKeyPresses++;
            debugLog(`âœ… ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æ¤œå‡º: ${e.code}`);
          }
        };

        document.addEventListener("keydown", testHandler);

        setTimeout(() => {
          document.removeEventListener("keydown", testHandler);
          debugLog("âŒ¨ï¸ ã‚­ãƒ¼æ¤œå‡ºãƒ†ã‚¹ãƒˆå®Œäº†:");
          debugLog(`  ç·ã‚­ãƒ¼æŠ¼ä¸‹: ${testResults.totalKeyPresses}å›`);
          debugLog(`  ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼æŠ¼ä¸‹: ${testResults.jumpKeyPresses}å›`);
          debugLog(
            `  æ¤œå‡ºã•ã‚ŒãŸã‚­ãƒ¼: ${[...new Set(testResults.detectedKeys)].join(
              ", "
            )}`
          );
        }, 5000);

        return testResults;
      }

      // åˆæœŸåŒ–
      window.addEventListener("load", () => {
        debugLogElement = document.getElementById("debug-log");
        debugLog("ğŸš€ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¸ãƒ£ãƒ³ãƒ—ä¿®æ­£ç‰ˆåˆæœŸåŒ–ä¸­...");

        try {
          game = new FixedGame();
          debugLog("ğŸ® ã‚²ãƒ¼ãƒ æº–å‚™å®Œäº†ï¼");
          debugLog("ğŸ”§ ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚¸ãƒ£ãƒ³ãƒ—ã‚’è©¦ã—ã¦ãã ã•ã„ï¼");

          // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦å…¬é–‹
          window.game = game;
          window.testJump = testJump;
          window.forceJump = forceJump;
          window.resetPlayer = resetPlayer;
          window.debugInput = debugInput;
          window.testKeyDetection = testKeyDetection;
        } catch (error) {
          debugLog("âŒ åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: " + error.message);
          console.error("åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:", error);
        }
      });
    </script>
  </body>
</html>
