/**
 * Comprehensive Test Suite for Fallback Input System
 * Tests all requirements: 6.1, 6.2, 6.3, 6.4
 */

class FallbackInputSystemTest {
  constructor() {
    this.testResults = {
      requirement_6_1: { passed: false, details: [] }, // „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅåÁÑ°ÂäπÊôÇ„ÅÆ‰∏äÁü¢Âç∞„Ç≠„Éº
      requirement_6_2: { passed: false, details: [] }, // „Ç≠„Éº„Éú„Éº„Éâ‰ΩøÁî®‰∏çÂèØÊôÇ„ÅÆÁîªÈù¢‰∏ä„Éú„Çø„É≥
      requirement_6_3: { passed: false, details: [] }, // „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„Çπ„Åß„ÅÆ„Çø„ÉÉ„ÉóÊìç‰Ωú
      requirement_6_4: { passed: false, details: [] }, // „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£Ë®≠ÂÆö„Åß„ÅÆ„Ç≠„Éº„Éê„Ç§„É≥„ÉâÂ§âÊõ¥
    };

    this.fallbackInputSystem = null;
    this.mockGameEngine = null;
  }

  /**
   * Initialize test environment
   */
  async init() {
    console.log("üß™ Initializing Fallback Input System Test Suite...");

    // Create mock canvas
    const mockCanvas = document.createElement("canvas");
    mockCanvas.width = 800;
    mockCanvas.height = 600;
    document.body.appendChild(mockCanvas);

    // Create mock game engine
    this.mockGameEngine = {
      canvas: mockCanvas,
      inputManager: new InputManager(mockCanvas),
    };

    // Initialize fallback input system
    try {
      this.fallbackInputSystem = new FallbackInputSystem(this.mockGameEngine);
      console.log("‚úÖ FallbackInputSystem initialized for testing");
      return true;
    } catch (error) {
      console.error("‚ùå Failed to initialize FallbackInputSystem:", error);
      return false;
    }
  }

  /**
   * Run all tests
   */
  async runAllTests() {
    console.log("üöÄ Starting comprehensive fallback input system tests...");

    if (!(await this.init())) {
      console.error("‚ùå Test initialization failed");
      return this.testResults;
    }

    // Test Requirement 6.1: ‰∏äÁü¢Âç∞„Ç≠„Éº„Å´„Çà„Çã„Ç∏„É£„É≥„ÉóÊ©üËÉΩ
    await this.testRequirement6_1();

    // Test Requirement 6.2: ÁîªÈù¢‰∏ä„ÅÆ„Ç∏„É£„É≥„Éó„Éú„Çø„É≥
    await this.testRequirement6_2();

    // Test Requirement 6.3: „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÁî®„ÅÆ„Çø„ÉÉ„ÉóÊìç‰Ωú
    await this.testRequirement6_3();

    // Test Requirement 6.4: „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£Ë®≠ÂÆö
    await this.testRequirement6_4();

    // Generate final report
    this.generateTestReport();

    return this.testResults;
  }

  /**
   * Test Requirement 6.1: ‰∏äÁü¢Âç∞„Ç≠„Éº„Å´„Çà„Çã„Ç∏„É£„É≥„ÉóÊ©üËÉΩ„ÅÆÁ¢∫ÂÆü„Å™Âãï‰Ωú„ÇíÊ§úË®º
   */
  async testRequirement6_1() {
    console.log("üìã Testing Requirement 6.1: Up Arrow Key Jump Functionality");

    const details = [];
    let passed = true;

    try {
      // Test 1: Verify up arrow key is bound to jump
      const jumpKeys = this.mockGameEngine.inputManager.keyBindings.jump || [];
      const upArrowBound = jumpKeys.includes("ArrowUp");

      details.push(`Up arrow key bound to jump: ${upArrowBound ? "‚úÖ" : "‚ùå"}`);
      if (!upArrowBound) passed = false;

      // Test 2: Simulate up arrow key press and verify jump action
      const originalActionState =
        this.mockGameEngine.inputManager.actionStates.get("jump");

      // Simulate keydown event
      const keyDownEvent = new KeyboardEvent("keydown", {
        code: "ArrowUp",
        key: "ArrowUp",
        bubbles: true,
      });

      document.dispatchEvent(keyDownEvent);
      this.mockGameEngine.inputManager.update();

      const jumpActionTriggered =
        this.mockGameEngine.inputManager.isActionPressed("jump");
      details.push(
        `Up arrow key triggers jump action: ${
          jumpActionTriggered ? "‚úÖ" : "‚ùå"
        }`
      );
      if (!jumpActionTriggered) passed = false;

      // Test 3: Verify alternative key verification function
      const verificationResult = this.fallbackInputSystem.verifyUpArrowJump();
      details.push(
        `Up arrow verification function works: ${
          verificationResult.upArrowBound ? "‚úÖ" : "‚ùå"
        }`
      );
      if (!verificationResult.upArrowBound) passed = false;

      // Test 4: Test other alternative jump keys
      const alternativeKeys = ["KeyW", "Enter"];
      for (const key of alternativeKeys) {
        const keyEvent = new KeyboardEvent("keydown", {
          code: key,
          key: key === "KeyW" ? "w" : "Enter",
          bubbles: true,
        });

        document.dispatchEvent(keyEvent);
        this.mockGameEngine.inputManager.update();

        const altKeyWorks =
          this.mockGameEngine.inputManager.isActionPressed("jump");
        details.push(
          `Alternative key ${key} triggers jump: ${altKeyWorks ? "‚úÖ" : "‚ùå"}`
        );
        if (!altKeyWorks) passed = false;
      }
    } catch (error) {
      details.push(`‚ùå Error during testing: ${error.message}`);
      passed = false;
    }

    this.testResults.requirement_6_1 = { passed, details };
    console.log(`Requirement 6.1: ${passed ? "‚úÖ PASSED" : "‚ùå FAILED"}`);
  }

  /**
   * Test Requirement 6.2: „Ç≠„Éº„Éú„Éº„Éâ„Åå‰ΩøÁî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà„ÅÆÁîªÈù¢‰∏ä„Ç∏„É£„É≥„Éó„Éú„Çø„É≥
   */
  async testRequirement6_2() {
    console.log("üìã Testing Requirement 6.2: On-Screen Jump Button");

    const details = [];
    let passed = true;

    try {
      // Test 1: Check if on-screen controls are created
      const jumpButton = document.getElementById("fallback-jump-button");
      const jumpButtonExists = !!jumpButton;

      details.push(
        `On-screen jump button created: ${jumpButtonExists ? "‚úÖ" : "‚ùå"}`
      );
      if (!jumpButtonExists) passed = false;

      if (jumpButtonExists) {
        // Test 2: Verify button properties
        const buttonVisible = jumpButton.style.display !== "none";
        const buttonClickable = jumpButton.style.pointerEvents !== "none";

        details.push(`Jump button visible: ${buttonVisible ? "‚úÖ" : "‚ùå"}`);
        details.push(`Jump button clickable: ${buttonClickable ? "‚úÖ" : "‚ùå"}`);

        if (!buttonVisible || !buttonClickable) passed = false;

        // Test 3: Test button functionality
        let jumpTriggered = false;
        const jumpHandler = (e) => {
          if (e.detail.pressed) jumpTriggered = true;
        };

        document.addEventListener("fallbackJump", jumpHandler);

        // Simulate button click
        const clickEvent = new MouseEvent("mousedown", { bubbles: true });
        jumpButton.dispatchEvent(clickEvent);

        // Wait a bit for event processing
        await new Promise((resolve) => setTimeout(resolve, 50));

        details.push(
          `Jump button triggers fallback jump: ${jumpTriggered ? "‚úÖ" : "‚ùå"}`
        );
        if (!jumpTriggered) passed = false;

        document.removeEventListener("fallbackJump", jumpHandler);
      }

      // Test 4: Check movement buttons
      const leftButton =
        this.fallbackInputSystem.onScreenControls.moveButtons?.left;
      const rightButton =
        this.fallbackInputSystem.onScreenControls.moveButtons?.right;

      details.push(
        `Left movement button created: ${!!leftButton ? "‚úÖ" : "‚ùå"}`
      );
      details.push(
        `Right movement button created: ${!!rightButton ? "‚úÖ" : "‚ùå"}`
      );

      if (!leftButton || !rightButton) passed = false;

      // Test 5: Test toggle functionality
      const initialVisibility =
        this.fallbackInputSystem.settings.showOnScreenControls;
      const toggleResult = this.fallbackInputSystem.toggleOnScreenControls(
        !initialVisibility
      );

      details.push(
        `On-screen controls toggle works: ${
          toggleResult === !initialVisibility ? "‚úÖ" : "‚ùå"
        }`
      );
      if (toggleResult !== !initialVisibility) passed = false;
    } catch (error) {
      details.push(`‚ùå Error during testing: ${error.message}`);
      passed = false;
    }

    this.testResults.requirement_6_2 = { passed, details };
    console.log(`Requirement 6.2: ${passed ? "‚úÖ PASSED" : "‚ùå FAILED"}`);
  }

  /**
   * Test Requirement 6.3: „Çø„ÉÉ„ÉÅ„Éá„Éê„Ç§„ÇπÁî®„ÅÆ„Çø„ÉÉ„ÉóÊìç‰Ωú„Åß„Ç∏„É£„É≥„ÉóÂÆüË°å
   */
  async testRequirement6_3() {
    console.log("üìã Testing Requirement 6.3: Touch Device Tap Controls");

    const details = [];
    let passed = true;

    try {
      // Test 1: Check touch support detection
      const touchSupported = this.fallbackInputSystem.touchSupported;
      details.push(`Touch support detected: ${touchSupported ? "‚úÖ" : "‚ùå"}`);

      // Test 2: Test direct touch handler functionality
      let touchJumpTriggered = false;
      const touchJumpHandler = (e) => {
        if (e.detail.pressed) touchJumpTriggered = true;
      };

      document.addEventListener("fallbackJump", touchJumpHandler);

      // Simulate touch jump
      this.fallbackInputSystem.handleFallbackJump(true);
      await new Promise((resolve) => setTimeout(resolve, 50));

      details.push(
        `Direct touch jump handler works: ${touchJumpTriggered ? "‚úÖ" : "‚ùå"}`
      );
      if (!touchJumpTriggered) passed = false;

      document.removeEventListener("fallbackJump", touchJumpHandler);

      // Test 3: Test touch movement handlers
      let touchMoveTriggered = false;
      const touchMoveHandler = (e) => {
        if (e.detail.direction === "left" && e.detail.pressed) {
          touchMoveTriggered = true;
        }
      };

      document.addEventListener("fallbackMove", touchMoveHandler);

      this.fallbackInputSystem.handleFallbackMove("left", true);
      await new Promise((resolve) => setTimeout(resolve, 50));

      details.push(
        `Touch movement handler works: ${touchMoveTriggered ? "‚úÖ" : "‚ùå"}`
      );
      if (!touchMoveTriggered) passed = false;

      document.removeEventListener("fallbackMove", touchMoveHandler);

      // Test 4: Test touch button integration with input manager
      const originalJumpState =
        this.mockGameEngine.inputManager.actionStates.get("jump");

      this.fallbackInputSystem.handleFallbackJump(true);
      const jumpStateAfterTouch =
        this.mockGameEngine.inputManager.actionStates.get("jump");

      details.push(
        `Touch input integrates with input manager: ${
          jumpStateAfterTouch ? "‚úÖ" : "‚ùå"
        }`
      );
      if (!jumpStateAfterTouch) passed = false;

      // Test 5: Test haptic feedback (if available)
      const vibrationSupported = "vibrate" in navigator;
      details.push(
        `Haptic feedback support: ${
          vibrationSupported ? "‚úÖ" : "‚ö†Ô∏è Not available"
        }`
      );
    } catch (error) {
      details.push(`‚ùå Error during testing: ${error.message}`);
      passed = false;
    }

    this.testResults.requirement_6_3 = { passed, details };
    console.log(`Requirement 6.3: ${passed ? "‚úÖ PASSED" : "‚ùå FAILED"}`);
  }

  /**
   * Test Requirement 6.4: „Ç¢„ÇØ„Çª„Ç∑„Éì„É™„ÉÜ„Ç£Ë®≠ÂÆö„Åß„Ç≠„Éº„Éê„Ç§„É≥„ÉâÂ§âÊõ¥
   */
  async testRequirement6_4() {
    console.log(
      "üìã Testing Requirement 6.4: Accessibility Key Binding Settings"
    );

    const details = [];
    let passed = true;

    try {
      // Test 1: Check if alternative keys are properly bound
      const alternativeKeys = this.fallbackInputSystem.alternativeKeys;
      const jumpAlternatives = alternativeKeys.jump || [];

      details.push(
        `Alternative jump keys defined: ${
          jumpAlternatives.length > 0 ? "‚úÖ" : "‚ùå"
        }`
      );
      if (jumpAlternatives.length === 0) passed = false;

      // Test 2: Verify all alternative keys are bound to input manager
      for (const key of jumpAlternatives) {
        const isBound =
          this.mockGameEngine.inputManager.keyBindings.jump?.includes(key);
        details.push(`Alternative key ${key} bound: ${isBound ? "‚úÖ" : "‚ùå"}`);
        if (!isBound) passed = false;
      }

      // Test 3: Test key binding modification functionality
      const testKey = "KeyT"; // Test key
      const originalBindings = [
        ...(this.mockGameEngine.inputManager.keyBindings.jump || []),
      ];

      // Add test key
      this.mockGameEngine.inputManager.bindKey(testKey, "jump");
      const keyAdded =
        this.mockGameEngine.inputManager.keyBindings.jump?.includes(testKey);

      details.push(`Dynamic key binding works: ${keyAdded ? "‚úÖ" : "‚ùå"}`);
      if (!keyAdded) passed = false;

      // Remove test key
      this.mockGameEngine.inputManager.unbindKey(testKey, "jump");
      const keyRemoved =
        !this.mockGameEngine.inputManager.keyBindings.jump?.includes(testKey);

      details.push(`Dynamic key unbinding works: ${keyRemoved ? "‚úÖ" : "‚ùå"}`);
      if (!keyRemoved) passed = false;

      // Test 4: Check accessibility help system
      const helpElement = document.getElementById("fallback-help-text");
      const helpSystemExists = !!helpElement;

      details.push(
        `Accessibility help system created: ${helpSystemExists ? "‚úÖ" : "‚ùå"}`
      );
      if (!helpSystemExists) passed = false;

      // Test 5: Test help toggle functionality
      if (helpSystemExists) {
        const initialDisplay = helpElement.style.display;

        // Simulate H key press to toggle help
        const helpToggleEvent = new KeyboardEvent("keydown", {
          code: "KeyH",
          key: "h",
          bubbles: true,
        });

        document.dispatchEvent(helpToggleEvent);

        const displayAfterToggle = helpElement.style.display;
        const helpToggleWorks = initialDisplay !== displayAfterToggle;

        details.push(
          `Help toggle functionality works: ${helpToggleWorks ? "‚úÖ" : "‚ùå"}`
        );
        if (!helpToggleWorks) passed = false;
      }

      // Test 6: Test settings persistence
      const settings = this.fallbackInputSystem.settings;
      const hasSettings = settings && typeof settings === "object";

      details.push(`Settings system exists: ${hasSettings ? "‚úÖ" : "‚ùå"}`);
      if (!hasSettings) passed = false;

      if (hasSettings) {
        const settingsKeys = [
          "showOnScreenControls",
          "enableAlternativeKeys",
          "vibrationEnabled",
        ];
        for (const key of settingsKeys) {
          const hasSetting = key in settings;
          details.push(`Setting '${key}' exists: ${hasSetting ? "‚úÖ" : "‚ùå"}`);
          if (!hasSetting) passed = false;
        }
      }
    } catch (error) {
      details.push(`‚ùå Error during testing: ${error.message}`);
      passed = false;
    }

    this.testResults.requirement_6_4 = { passed, details };
    console.log(`Requirement 6.4: ${passed ? "‚úÖ PASSED" : "‚ùå FAILED"}`);
  }

  /**
   * Generate comprehensive test report
   */
  generateTestReport() {
    console.log("\nüìä FALLBACK INPUT SYSTEM TEST REPORT");
    console.log("=====================================");

    let totalTests = 0;
    let passedTests = 0;

    for (const [requirement, result] of Object.entries(this.testResults)) {
      totalTests++;
      if (result.passed) passedTests++;

      console.log(
        `\n${requirement.toUpperCase()}: ${
          result.passed ? "‚úÖ PASSED" : "‚ùå FAILED"
        }`
      );
      for (const detail of result.details) {
        console.log(`  ${detail}`);
      }
    }

    console.log(
      `\nüìà SUMMARY: ${passedTests}/${totalTests} requirements passed`
    );
    console.log(
      `Success Rate: ${((passedTests / totalTests) * 100).toFixed(1)}%`
    );

    if (passedTests === totalTests) {
      console.log(
        "üéâ ALL TESTS PASSED! Fallback Input System is fully functional."
      );
    } else {
      console.log("‚ö†Ô∏è  Some tests failed. Please review the implementation.");
    }

    return {
      totalTests,
      passedTests,
      successRate: (passedTests / totalTests) * 100,
      allPassed: passedTests === totalTests,
    };
  }

  /**
   * Cleanup test environment
   */
  cleanup() {
    if (this.fallbackInputSystem) {
      this.fallbackInputSystem.destroy();
    }

    // Remove mock canvas
    const mockCanvas = this.mockGameEngine?.canvas;
    if (mockCanvas && mockCanvas.parentNode) {
      mockCanvas.parentNode.removeChild(mockCanvas);
    }

    console.log("üßπ Test environment cleaned up");
  }
}

// Export for use in other modules
if (typeof module !== "undefined" && module.exports) {
  module.exports = FallbackInputSystemTest;
} else {
  window.FallbackInputSystemTest = FallbackInputSystemTest;
}

// Auto-run tests if this script is loaded directly
if (
  typeof window !== "undefined" &&
  window.location.pathname.includes("test")
) {
  window.addEventListener("load", async () => {
    const testSuite = new FallbackInputSystemTest();
    await testSuite.runAllTests();
  });
}
